1. Print No of digits in a given number
123/10=12
12/10=1
1/10=0

Code:
```
let n=123;
let count=0;
        while(n>0){
         
                n=Math.floor(n/10);
                count++;
            
        }
     
   console.log(count);
```
Optimal approach using log base 10 means power of 10:

```
let n=12038761843;
let digits=Math.log10(n)

console.log(Math.floor(digits)+1);
```

2. Print digits in a number in a list form

code:

let n=1204565473;
let numberString=String(n).split('');
    console.log(numberString.map(Number));

3. reverse a Number

code:
```
let n=123456;
console.log('N is: '+n)
let reverseNumber=0;
while(n>0){
    let lastDigit=n%10;
    n=Math.floor(n/10);
    reverseNumber=reverseNumber*10+lastDigit;
    
}


console.log('Reverse Number is:'+reverseNumber)
```
4. Pallendrome Number

code:

```
let n=121;
let originalNumber=n;

let reverseNumber=0;
while(n>0){
    let lastDigit=n%10;
    n=Math.floor(n/10);
    reverseNumber=reverseNumber*10+lastDigit;
    
}
if(originalNumber===reverseNumber){
    console.log("Palindrome Number")
}else{
    console.log("Not Palindrome")
}

```

5. GCD of two numbers

My approach code:

```
let n1=125;
let n2=275;
let divisibles=[];

for(let i=1;i<=Math.min(n1,n2);i++){
    if(n1%i===0 && n2%i===0){
        divisibles.push(i);
    }
}

let gcd=Math.max(...divisibles);
console.log(gcd);

```
Better code2:

```
let n1=125;
let n2=275;

let min=Math.min(n1,n2);
let gcd=1;

for(let i=min;i>=1;i--){
    if(n1%i===0 && n2%i===0){
        gcd=i;
        break;
    }
}


console.log(gcd);
```

Optimal code:

```
function GCD(n1,n2){
   while(n1>0 && n2>0){
       if(n1>n2){
           n1=n1%n2
       }else{
           n2=n2%n1;
       }
   }
   
   if(n1===0){
       return n2;
   }else{
       return n1;
   }
    
}
let n1=125;
let n2=275;
let gcd=GCD(n1,n2)
console.log(gcd)
```

6. Armstrong Number

My code:
```
let n=1634;
let original=n;
let sum=0;
let len=String(n).length;

while(n>0){
    let ld=n%10;
    sum=sum+ld**len;
    n=Math.floor(n/10);
    
}


if(sum===original){
    console.log("Armstrong number");
}else{
    console.log("Not an Armstrong number");
}
```
7. Print Divisors

My code:
```
let n=3;
let divisors=[];
for(let i=1;i<=n;i++){
    if(n%i===0){
        divisors.push(i);
    }
}
console.log(divisors)
```

Optimal code with O(sqrt(n)):

```
let n=36;
let divisors=[];
for(let i=1;i*i<=n;i++){
    if(n%i===0){
        divisors.push(i);
        if(n/i!==i){
            divisors.push(n/i);
        }
    }
}
console.log(divisors.sort((a,b)=>a-b))
```
8. Check for Prime

code:
```
let n=24;
let count=0;
for(let i=1;i*i<=n;i++){
    if(n%i===0){
        count++;
        if(n/i!==i){
            count++;
        }
    }
}

if(count===2){
    console.log("Its a Prime Number")
}else{
    console.log("Its not a Prime Number")
}
```

9. Print something N times using recurssion

code:

```
function printN(i,N){
    if(i>N){
        return;
    }
    console.log("Ashu Dev");
    printN(i+1,N);
}
printN(1,3);
```
10. Print N-1 using recursion
code:

```
function printN(i,N){
    if(i<1){
        return;
    }
    console.log(i);
    printN(i-1,N);
}
printN(3,3);
```

11. Print 1-N using recursion (Backtracking)
code:
```


function printN(i,N){
    if(i<1){
        return;
    }
    printN(i-1,N);
    console.log(i);
}
printN(3,3);
```
12. Sum of first N numbers using recursion (parameterized recursion)

code:
```
function sumN(i,sum){ 
    if(i<1){ 
        return sum; 
        
    } 

return sumN(i-1,sum+i); 
    
} 
const sum=sumN(8,0); 
console.log(sum);
```
13. Print N-1 using recursion(Backtracking)

code:

```
function printN(i,N){
    if(i>N){
        return;
    }
    printN(i+1,N);
    console.log(i)
    
}

printN(1,3);
```

14. Sum of first N numbers using recursion (functional recursion)
code:
```
function sumN(n){
    if(n===0) return 0;
    return n+sumN(n-1);
} 
console.log(sumN(5));
```
15. factorial of a number using recursion
code:
```
function factN(n){
    if(n===0) return 1;
    return n*factN(n-1);
} 
console.log(factN(10));
```
16. reverse an array
a. Using two pointer without recursion:
code:
```
let arr=[1,2,3,4,2];
let f=0;
let l=arr.length-1;
console.log("Array before reverse",arr);
while(f<l){
    let temp=arr[f];
    arr[f]=arr[l];
    arr[l]=temp;
    f++;
    l--;
}

console.log("Array after reverse",arr);
```
b. with recursion:
My code (using two pointers):

```
function reverseArray(f,l,arr){
    if(f>=l){
        return;
    }
    let temp=arr[f];
    arr[f]=arr[l];
    arr[l]=temp;
    reverseArray(f+1,l-1,arr)
    
    
}
let arr=[1,2,3,4,2];

console.log("Array before reverse",arr);
reverseArray(0,arr.length-1,arr);

console.log("Array after reverse",arr);
```

Using one pointer

```
function reverseArray(f,arr){
    if(f>=arr.length/2){
        return;
    }
    let temp=arr[f];
    arr[f]=arr[arr.length-f-1];
    arr[arr.length-f-1]=temp;
    reverseArray(f+1,arr)
    
    
}
let arr=[1,2,3,4,2];

console.log("Array before reverse",arr);
reverseArray(0,arr);

console.log("Array after reverse",arr);
```
17. nth fibonacci number
code:
```
function fib(i){
    if(i<=1) return i;
    let last=fib(i-1);
    let slast=fib(i-2);
    return last+slast;
    
}

console.log(fib(7));
``` 
18. count frequencies of a number
code: (using hash)

```
let numbers= [1, 5, 10, 10, 1e10, 5, 2, 1e10, 1, 10];
let freqMap=new Map();

for(let num of numbers){
    let currentCount=freqMap.get(num) || 0;
    
    freqMap.set(num,currentCount+1);
}


console.log(freqMap);


```

** Merge Sort

```
function mergeAlgo(arr,l,mid,h){
    let left=l;
    let temp=[]
    let right=mid+1;
    while(left<=mid && right<=h){
        if(arr[left]<=arr[right]){
            temp.push(arr[left]);
            left++
        }else{
            temp.push(arr[right]);
            right++
        }
    }
    
    while(left<=mid){
        temp.push(arr[left]);
        left++;
    }
    
    while(right<=h){
        temp.push(arr[right]);
        right++;
    }
    
    for(let i=l;i<=h;i++){
        arr[i]=temp[i-l]
    }
}

function mergeSort(arr,l,r){
    if(l>=r) return;
    let mid=Math.floor((l+r)/2);
    mergeSort(arr,l,mid);
    mergeSort(arr,mid+1,r);
    mergeAlgo(arr,l,mid,r);
    
    
}

// let arr=[3,2,4,1,3];
let arr=[4,3,2,1]
console.log("Before mergeSort: ",arr);
mergeSort(arr,0,arr.length-1)
console.log("After mergeSort: ",arr);


```
2. Quick Sort Algorithm

```
function soting(arr,l,r){
    let pivot=arr[l];
    let i=l;
    let j=r;
  
        while(i<j){
            while(arr[i]<=pivot && i<=r) {
                i++;
            }
            while(arr[j]>pivot && j>=i){
                j--
            }
            if(i<j){
                [arr[i],arr[j]]=[arr[j],arr[i]];
            }
        }
        
        
            [arr[l],arr[j]]=[arr[j],arr[l]];
            return j;
        

}

function qsort(arr,l,r){
    
    if(l<r){
    let part=soting(arr,l,r);
    qsort(arr,l,part);
    qsort(arr,part+1,r);
    }
    
}

let arr=[4,6,2,5,7,9,1,3];
qsort(arr,0,arr.length-1);
console.log("array after sorting: ",arr)



```

